
RobotRunGrid.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000010  00800100  00000276  000002ea  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000276  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .comment      00000030  00000000  00000000  000002fa  2**0
                  CONTENTS, READONLY
  3 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  0000032c  2**2
                  CONTENTS, READONLY
  4 .debug_aranges 00000048  00000000  00000000  0000036c  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   000008c0  00000000  00000000  000003b4  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00000743  00000000  00000000  00000c74  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00000309  00000000  00000000  000013b7  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  000000d0  00000000  00000000  000016c0  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00000375  00000000  00000000  00001790  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00000522  00000000  00000000  00001b05  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000060  00000000  00000000  00002027  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 34 00 	jmp	0x68	; 0x68 <__ctors_end>
   4:	0c 94 49 00 	jmp	0x92	; 0x92 <__bad_interrupt>
   8:	0c 94 49 00 	jmp	0x92	; 0x92 <__bad_interrupt>
   c:	0c 94 49 00 	jmp	0x92	; 0x92 <__bad_interrupt>
  10:	0c 94 49 00 	jmp	0x92	; 0x92 <__bad_interrupt>
  14:	0c 94 49 00 	jmp	0x92	; 0x92 <__bad_interrupt>
  18:	0c 94 49 00 	jmp	0x92	; 0x92 <__bad_interrupt>
  1c:	0c 94 49 00 	jmp	0x92	; 0x92 <__bad_interrupt>
  20:	0c 94 49 00 	jmp	0x92	; 0x92 <__bad_interrupt>
  24:	0c 94 49 00 	jmp	0x92	; 0x92 <__bad_interrupt>
  28:	0c 94 49 00 	jmp	0x92	; 0x92 <__bad_interrupt>
  2c:	0c 94 49 00 	jmp	0x92	; 0x92 <__bad_interrupt>
  30:	0c 94 49 00 	jmp	0x92	; 0x92 <__bad_interrupt>
  34:	0c 94 49 00 	jmp	0x92	; 0x92 <__bad_interrupt>
  38:	0c 94 49 00 	jmp	0x92	; 0x92 <__bad_interrupt>
  3c:	0c 94 49 00 	jmp	0x92	; 0x92 <__bad_interrupt>
  40:	0c 94 49 00 	jmp	0x92	; 0x92 <__bad_interrupt>
  44:	0c 94 49 00 	jmp	0x92	; 0x92 <__bad_interrupt>
  48:	0c 94 49 00 	jmp	0x92	; 0x92 <__bad_interrupt>
  4c:	0c 94 49 00 	jmp	0x92	; 0x92 <__bad_interrupt>
  50:	0c 94 49 00 	jmp	0x92	; 0x92 <__bad_interrupt>
  54:	0c 94 49 00 	jmp	0x92	; 0x92 <__bad_interrupt>
  58:	0c 94 49 00 	jmp	0x92	; 0x92 <__bad_interrupt>
  5c:	0c 94 49 00 	jmp	0x92	; 0x92 <__bad_interrupt>
  60:	0c 94 49 00 	jmp	0x92	; 0x92 <__bad_interrupt>
  64:	0c 94 49 00 	jmp	0x92	; 0x92 <__bad_interrupt>

00000068 <__ctors_end>:
  68:	11 24       	eor	r1, r1
  6a:	1f be       	out	0x3f, r1	; 63
  6c:	cf ef       	ldi	r28, 0xFF	; 255
  6e:	d8 e0       	ldi	r29, 0x08	; 8
  70:	de bf       	out	0x3e, r29	; 62
  72:	cd bf       	out	0x3d, r28	; 61

00000074 <__do_copy_data>:
  74:	11 e0       	ldi	r17, 0x01	; 1
  76:	a0 e0       	ldi	r26, 0x00	; 0
  78:	b1 e0       	ldi	r27, 0x01	; 1
  7a:	e6 e7       	ldi	r30, 0x76	; 118
  7c:	f2 e0       	ldi	r31, 0x02	; 2
  7e:	02 c0       	rjmp	.+4      	; 0x84 <__do_copy_data+0x10>
  80:	05 90       	lpm	r0, Z+
  82:	0d 92       	st	X+, r0
  84:	a0 31       	cpi	r26, 0x10	; 16
  86:	b1 07       	cpc	r27, r17
  88:	d9 f7       	brne	.-10     	; 0x80 <__do_copy_data+0xc>
  8a:	0e 94 0b 01 	call	0x216	; 0x216 <main>
  8e:	0c 94 39 01 	jmp	0x272	; 0x272 <_exit>

00000092 <__bad_interrupt>:
  92:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000096 <sortOrder>:
	temp = *d;
	*d = *c;
	*c = temp;
}

void sortOrder(int X[], int Y[]) {
  96:	2f 92       	push	r2
  98:	3f 92       	push	r3
  9a:	4f 92       	push	r4
  9c:	5f 92       	push	r5
  9e:	6f 92       	push	r6
  a0:	7f 92       	push	r7
  a2:	8f 92       	push	r8
  a4:	9f 92       	push	r9
  a6:	af 92       	push	r10
  a8:	bf 92       	push	r11
  aa:	cf 92       	push	r12
  ac:	df 92       	push	r13
  ae:	ef 92       	push	r14
  b0:	ff 92       	push	r15
  b2:	0f 93       	push	r16
  b4:	1f 93       	push	r17
  b6:	cf 93       	push	r28
  b8:	df 93       	push	r29
  ba:	5b 01       	movw	r10, r22
  bc:	86 2e       	mov	r8, r22
  be:	7b 2c       	mov	r7, r11
  c0:	68 2e       	mov	r6, r24
  c2:	59 2e       	mov	r5, r25
  c4:	8b 01       	movw	r16, r22
  c6:	0a 5f       	subi	r16, 0xFA	; 250
  c8:	1f 4f       	sbci	r17, 0xFF	; 255
  ca:	99 24       	eor	r9, r9
  cc:	93 94       	inc	r9
  ce:	41 2c       	mov	r4, r1
	while (check != 1) {                                                                     //sort on Y-coördinates (ascending)
		orderCorrect = 1;
		for (int i = 0; i < (sizeOfOrder - 1); i++) {
			if (Y[i] > Y[i + 1]) {
				swapTwo(&X[i], &X[i + 1], &Y[i], &Y[i + 1]);
				orderCorrect = 0;
  d0:	31 2c       	mov	r3, r1
  d2:	21 2c       	mov	r2, r1
  d4:	28 c0       	rjmp	.+80     	; 0x126 <sortOrder+0x90>
	int check = 0, orderCorrect, toggle = 0;

	while (check != 1) {                                                                     //sort on Y-coördinates (ascending)
		orderCorrect = 1;
		for (int i = 0; i < (sizeOfOrder - 1); i++) {
			if (Y[i] > Y[i + 1]) {
  d6:	c0 81       	ld	r28, Z
  d8:	d1 81       	ldd	r29, Z+1	; 0x01
  da:	42 81       	ldd	r20, Z+2	; 0x02
  dc:	53 81       	ldd	r21, Z+3	; 0x03
  de:	4c 17       	cp	r20, r28
  e0:	5d 07       	cpc	r21, r29
  e2:	c4 f4       	brge	.+48     	; 0x114 <sortOrder+0x7e>
#include "Grid.h"

void swapTwo( int *a, int *b, int *c, int *d){
	int temp;

	temp = *b;
  e4:	12 96       	adiw	r26, 0x02	; 2
  e6:	2d 91       	ld	r18, X+
  e8:	3c 91       	ld	r19, X
  ea:	13 97       	sbiw	r26, 0x03	; 3
	*b = *a;
  ec:	4d 91       	ld	r20, X+
  ee:	5c 91       	ld	r21, X
  f0:	11 97       	sbiw	r26, 0x01	; 1
  f2:	13 96       	adiw	r26, 0x03	; 3
  f4:	5c 93       	st	X, r21
  f6:	4e 93       	st	-X, r20
  f8:	12 97       	sbiw	r26, 0x02	; 2
	*a = temp;
  fa:	11 96       	adiw	r26, 0x01	; 1
  fc:	3c 93       	st	X, r19
  fe:	2e 93       	st	-X, r18

	temp = *d;
 100:	22 81       	ldd	r18, Z+2	; 0x02
 102:	33 81       	ldd	r19, Z+3	; 0x03
	*d = *c;
 104:	40 81       	ld	r20, Z
 106:	51 81       	ldd	r21, Z+1	; 0x01
 108:	53 83       	std	Z+3, r21	; 0x03
 10a:	42 83       	std	Z+2, r20	; 0x02
	*c = temp;
 10c:	31 83       	std	Z+1, r19	; 0x01
 10e:	20 83       	st	Z, r18
	while (check != 1) {                                                                     //sort on Y-coördinates (ascending)
		orderCorrect = 1;
		for (int i = 0; i < (sizeOfOrder - 1); i++) {
			if (Y[i] > Y[i + 1]) {
				swapTwo(&X[i], &X[i + 1], &Y[i], &Y[i + 1]);
				orderCorrect = 0;
 110:	23 2d       	mov	r18, r3
 112:	32 2d       	mov	r19, r2
 114:	32 96       	adiw	r30, 0x02	; 2
 116:	12 96       	adiw	r26, 0x02	; 2
void sortOrder(int X[], int Y[]) {
	int check = 0, orderCorrect, toggle = 0;

	while (check != 1) {                                                                     //sort on Y-coördinates (ascending)
		orderCorrect = 1;
		for (int i = 0; i < (sizeOfOrder - 1); i++) {
 118:	e0 17       	cp	r30, r16
 11a:	f1 07       	cpc	r31, r17
 11c:	e1 f6       	brne	.-72     	; 0xd6 <sortOrder+0x40>
			if (Y[i] > Y[i + 1]) {
				swapTwo(&X[i], &X[i + 1], &Y[i], &Y[i + 1]);
				orderCorrect = 0;
			}
		}
		if (orderCorrect == 1) {
 11e:	21 30       	cpi	r18, 0x01	; 1
 120:	31 05       	cpc	r19, r1
 122:	09 f4       	brne	.+2      	; 0x126 <sortOrder+0x90>
 124:	5a c0       	rjmp	.+180    	; 0x1da <sortOrder+0x144>
 126:	c8 2c       	mov	r12, r8
 128:	67 2d       	mov	r22, r7
 12a:	76 2d       	mov	r23, r6
 12c:	d5 2c       	mov	r13, r5
 12e:	78 01       	movw	r14, r16
	temp = *d;
	*d = *c;
	*c = temp;
}

void sortOrder(int X[], int Y[]) {
 130:	a8 2f       	mov	r26, r24
 132:	b9 2f       	mov	r27, r25
 134:	f5 01       	movw	r30, r10
 136:	29 2d       	mov	r18, r9
 138:	34 2d       	mov	r19, r4
 13a:	cd cf       	rjmp	.-102    	; 0xd6 <sortOrder+0x40>
	}
	check = 0;
	while (check != 1) {
		orderCorrect = 1;
		for (int i = 0; i < (sizeOfOrder - 1); i++) {                                       //check if Y is even or odd
			if (Y[i] % 2 == 0) {
 13c:	80 81       	ld	r24, Z
 13e:	91 81       	ldd	r25, Z+1	; 0x01
				toggle = 0;
			}
			else {
				toggle = 1;
			}
			if ((toggle == 1) && (Y[i] == Y[i + 1]) && (X[i] < X[i + 1])) {                 //if Y is odd put X-coördinates in descending order
 140:	80 ff       	sbrs	r24, 0
 142:	21 c0       	rjmp	.+66     	; 0x186 <sortOrder+0xf0>
 144:	42 81       	ldd	r20, Z+2	; 0x02
 146:	53 81       	ldd	r21, Z+3	; 0x03
 148:	84 17       	cp	r24, r20
 14a:	95 07       	cpc	r25, r21
 14c:	e1 f5       	brne	.+120    	; 0x1c6 <sortOrder+0x130>
 14e:	4d 91       	ld	r20, X+
 150:	5c 91       	ld	r21, X
 152:	11 97       	sbiw	r26, 0x01	; 1
 154:	12 96       	adiw	r26, 0x02	; 2
 156:	8d 91       	ld	r24, X+
 158:	9c 91       	ld	r25, X
 15a:	13 97       	sbiw	r26, 0x03	; 3
 15c:	48 17       	cp	r20, r24
 15e:	59 07       	cpc	r21, r25
 160:	94 f5       	brge	.+100    	; 0x1c6 <sortOrder+0x130>

void swapTwo( int *a, int *b, int *c, int *d){
	int temp;

	temp = *b;
	*b = *a;
 162:	13 96       	adiw	r26, 0x03	; 3
 164:	5c 93       	st	X, r21
 166:	4e 93       	st	-X, r20
 168:	12 97       	sbiw	r26, 0x02	; 2
	*a = temp;
 16a:	11 96       	adiw	r26, 0x01	; 1
 16c:	9c 93       	st	X, r25
 16e:	8e 93       	st	-X, r24

	temp = *d;
 170:	82 81       	ldd	r24, Z+2	; 0x02
 172:	93 81       	ldd	r25, Z+3	; 0x03
	*d = *c;
 174:	20 81       	ld	r18, Z
 176:	31 81       	ldd	r19, Z+1	; 0x01
 178:	33 83       	std	Z+3, r19	; 0x03
 17a:	22 83       	std	Z+2, r18	; 0x02
	*c = temp;
 17c:	91 83       	std	Z+1, r25	; 0x01
 17e:	80 83       	st	Z, r24
			else {
				toggle = 1;
			}
			if ((toggle == 1) && (Y[i] == Y[i + 1]) && (X[i] < X[i + 1])) {                 //if Y is odd put X-coördinates in descending order
				swapTwo(&X[i], &X[i + 1], &Y[i], &Y[i + 1]);
				orderCorrect = 0;
 180:	2b 2d       	mov	r18, r11
 182:	3a 2d       	mov	r19, r10
 184:	20 c0       	rjmp	.+64     	; 0x1c6 <sortOrder+0x130>
			}
			else if((toggle == 0) && (Y[i] == Y[i + 1]) && (X[i] > X[i + 1])){              //if Y is even put X-coördinates in ascending order
 186:	42 81       	ldd	r20, Z+2	; 0x02
 188:	53 81       	ldd	r21, Z+3	; 0x03
 18a:	84 17       	cp	r24, r20
 18c:	95 07       	cpc	r25, r21
 18e:	d9 f4       	brne	.+54     	; 0x1c6 <sortOrder+0x130>
 190:	4d 91       	ld	r20, X+
 192:	5c 91       	ld	r21, X
 194:	11 97       	sbiw	r26, 0x01	; 1
 196:	12 96       	adiw	r26, 0x02	; 2
 198:	8d 91       	ld	r24, X+
 19a:	9c 91       	ld	r25, X
 19c:	13 97       	sbiw	r26, 0x03	; 3
 19e:	84 17       	cp	r24, r20
 1a0:	95 07       	cpc	r25, r21
 1a2:	8c f4       	brge	.+34     	; 0x1c6 <sortOrder+0x130>

void swapTwo( int *a, int *b, int *c, int *d){
	int temp;

	temp = *b;
	*b = *a;
 1a4:	13 96       	adiw	r26, 0x03	; 3
 1a6:	5c 93       	st	X, r21
 1a8:	4e 93       	st	-X, r20
 1aa:	12 97       	sbiw	r26, 0x02	; 2
	*a = temp;
 1ac:	11 96       	adiw	r26, 0x01	; 1
 1ae:	9c 93       	st	X, r25
 1b0:	8e 93       	st	-X, r24

	temp = *d;
 1b2:	82 81       	ldd	r24, Z+2	; 0x02
 1b4:	93 81       	ldd	r25, Z+3	; 0x03
	*d = *c;
 1b6:	20 81       	ld	r18, Z
 1b8:	31 81       	ldd	r19, Z+1	; 0x01
 1ba:	33 83       	std	Z+3, r19	; 0x03
 1bc:	22 83       	std	Z+2, r18	; 0x02
	*c = temp;
 1be:	91 83       	std	Z+1, r25	; 0x01
 1c0:	80 83       	st	Z, r24
				swapTwo(&X[i], &X[i + 1], &Y[i], &Y[i + 1]);
				orderCorrect = 0;
			}
			else if((toggle == 0) && (Y[i] == Y[i + 1]) && (X[i] > X[i + 1])){              //if Y is even put X-coördinates in ascending order
				swapTwo(&X[i], &X[i + 1], &Y[i], &Y[i + 1]);
				orderCorrect = 0;
 1c2:	2b 2d       	mov	r18, r11
 1c4:	3a 2d       	mov	r19, r10
 1c6:	32 96       	adiw	r30, 0x02	; 2
 1c8:	12 96       	adiw	r26, 0x02	; 2
		}
	}
	check = 0;
	while (check != 1) {
		orderCorrect = 1;
		for (int i = 0; i < (sizeOfOrder - 1); i++) {                                       //check if Y is even or odd
 1ca:	ee 15       	cp	r30, r14
 1cc:	ff 05       	cpc	r31, r15
 1ce:	09 f0       	breq	.+2      	; 0x1d2 <sortOrder+0x13c>
 1d0:	b5 cf       	rjmp	.-150    	; 0x13c <sortOrder+0xa6>
			else if((toggle == 0) && (Y[i] == Y[i + 1]) && (X[i] > X[i + 1])){              //if Y is even put X-coördinates in ascending order
				swapTwo(&X[i], &X[i + 1], &Y[i], &Y[i + 1]);
				orderCorrect = 0;
			}
		}
		if (orderCorrect == 1) {
 1d2:	21 30       	cpi	r18, 0x01	; 1
 1d4:	31 05       	cpc	r19, r1
 1d6:	29 f4       	brne	.+10     	; 0x1e2 <sortOrder+0x14c>
 1d8:	0b c0       	rjmp	.+22     	; 0x1f0 <sortOrder+0x15a>
	while (check != 1) {                                                                     //sort on Y-coördinates (ascending)
		orderCorrect = 1;
		for (int i = 0; i < (sizeOfOrder - 1); i++) {
			if (Y[i] > Y[i + 1]) {
				swapTwo(&X[i], &X[i + 1], &Y[i], &Y[i + 1]);
				orderCorrect = 0;
 1da:	12 2f       	mov	r17, r18
 1dc:	03 2f       	mov	r16, r19
				swapTwo(&X[i], &X[i + 1], &Y[i], &Y[i + 1]);
				orderCorrect = 0;
			}
			else if((toggle == 0) && (Y[i] == Y[i + 1]) && (X[i] > X[i + 1])){              //if Y is even put X-coördinates in ascending order
				swapTwo(&X[i], &X[i + 1], &Y[i], &Y[i + 1]);
				orderCorrect = 0;
 1de:	b1 2c       	mov	r11, r1
 1e0:	a1 2c       	mov	r10, r1
	while (check != 1) {                                                                     //sort on Y-coördinates (ascending)
		orderCorrect = 1;
		for (int i = 0; i < (sizeOfOrder - 1); i++) {
			if (Y[i] > Y[i + 1]) {
				swapTwo(&X[i], &X[i + 1], &Y[i], &Y[i + 1]);
				orderCorrect = 0;
 1e2:	a7 2f       	mov	r26, r23
 1e4:	bd 2d       	mov	r27, r13
 1e6:	ec 2d       	mov	r30, r12
 1e8:	f6 2f       	mov	r31, r22
 1ea:	21 2f       	mov	r18, r17
 1ec:	30 2f       	mov	r19, r16
 1ee:	a6 cf       	rjmp	.-180    	; 0x13c <sortOrder+0xa6>
		}
		if (orderCorrect == 1) {
			check = 1;
		}
	}
 1f0:	df 91       	pop	r29
 1f2:	cf 91       	pop	r28
 1f4:	1f 91       	pop	r17
 1f6:	0f 91       	pop	r16
 1f8:	ff 90       	pop	r15
 1fa:	ef 90       	pop	r14
 1fc:	df 90       	pop	r13
 1fe:	cf 90       	pop	r12
 200:	bf 90       	pop	r11
 202:	af 90       	pop	r10
 204:	9f 90       	pop	r9
 206:	8f 90       	pop	r8
 208:	7f 90       	pop	r7
 20a:	6f 90       	pop	r6
 20c:	5f 90       	pop	r5
 20e:	4f 90       	pop	r4
 210:	3f 90       	pop	r3
 212:	2f 90       	pop	r2
 214:	08 95       	ret

00000216 <main>:
 Y = motor 2
 */

#include "Grid.h"

int main(){
 216:	cf 93       	push	r28
 218:	df 93       	push	r29
 21a:	cd b7       	in	r28, 0x3d	; 61
 21c:	de b7       	in	r29, 0x3e	; 62
 21e:	60 97       	sbiw	r28, 0x10	; 16
 220:	0f b6       	in	r0, 0x3f	; 63
 222:	f8 94       	cli
 224:	de bf       	out	0x3e, r29	; 62
 226:	0f be       	out	0x3f, r0	; 63
 228:	cd bf       	out	0x3d, r28	; 61
	
	int orderX[sizeOfOrder] = { 2, 5, 3, 4};    // replace with user input
 22a:	88 e0       	ldi	r24, 0x08	; 8
 22c:	e0 e0       	ldi	r30, 0x00	; 0
 22e:	f1 e0       	ldi	r31, 0x01	; 1
 230:	de 01       	movw	r26, r28
 232:	11 96       	adiw	r26, 0x01	; 1
 234:	01 90       	ld	r0, Z+
 236:	0d 92       	st	X+, r0
 238:	8a 95       	dec	r24
 23a:	e1 f7       	brne	.-8      	; 0x234 <main+0x1e>
	int orderY[sizeOfOrder] = { 3, 1, 4, 2};    // replace with user input
 23c:	88 e0       	ldi	r24, 0x08	; 8
 23e:	e8 e0       	ldi	r30, 0x08	; 8
 240:	f1 e0       	ldi	r31, 0x01	; 1
 242:	de 01       	movw	r26, r28
 244:	19 96       	adiw	r26, 0x09	; 9
 246:	01 90       	ld	r0, Z+
 248:	0d 92       	st	X+, r0
 24a:	8a 95       	dec	r24
 24c:	e1 f7       	brne	.-8      	; 0x246 <main+0x30>
	sortOrder(orderX, orderY);
 24e:	be 01       	movw	r22, r28
 250:	67 5f       	subi	r22, 0xF7	; 247
 252:	7f 4f       	sbci	r23, 0xFF	; 255
 254:	ce 01       	movw	r24, r28
 256:	01 96       	adiw	r24, 0x01	; 1
 258:	0e 94 4b 00 	call	0x96	; 0x96 <sortOrder>
				
 25c:	80 e0       	ldi	r24, 0x00	; 0
 25e:	90 e0       	ldi	r25, 0x00	; 0
 260:	60 96       	adiw	r28, 0x10	; 16
 262:	0f b6       	in	r0, 0x3f	; 63
 264:	f8 94       	cli
 266:	de bf       	out	0x3e, r29	; 62
 268:	0f be       	out	0x3f, r0	; 63
 26a:	cd bf       	out	0x3d, r28	; 61
 26c:	df 91       	pop	r29
 26e:	cf 91       	pop	r28
 270:	08 95       	ret

00000272 <_exit>:
 272:	f8 94       	cli

00000274 <__stop_program>:
 274:	ff cf       	rjmp	.-2      	; 0x274 <__stop_program>
